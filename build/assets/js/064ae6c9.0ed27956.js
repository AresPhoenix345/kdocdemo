"use strict";(globalThis.webpackChunkkubestellar_docs_initiative=globalThis.webpackChunkkubestellar_docs_initiative||[]).push([[6437],{7060(e,n,r){r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"migration/from-karmada","title":"Migrating from Karmada to KubeStellar","description":"Overview","source":"@site/docs/migration/from-karmada.md","sourceDirName":"migration","slug":"/migration/from-karmada","permalink":"/docs/migration/from-karmada","draft":false,"unlisted":false,"editUrl":"https://github.com/kubestellar/kubestellar/edit/main/kdemo/docs/migration/from-karmada.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Migrating from ArgoCD to KubeStellar","permalink":"/docs/migration/from-argocd"},"next":{"title":"Migrating from Cluster API to KubeStellar","permalink":"/docs/migration/from-cluster-api"}}');var l=r(4848),s=r(8453);const a={},t="Migrating from Karmada to KubeStellar",o={},d=[{value:"Overview",id:"overview",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Migration Strategy",id:"migration-strategy",level:2},{value:"Assessment Phase",id:"assessment-phase",level:3},{value:"Preparation Phase",id:"preparation-phase",level:3},{value:"Migration Phase",id:"migration-phase",level:3},{value:"Step 1: Translate placement policy",id:"step-1-translate-placement-policy",level:4},{value:"Step 2: Translate resource selection",id:"step-2-translate-resource-selection",level:4},{value:"Step 3: Handle overrides",id:"step-3-handle-overrides",level:4},{value:"Validation Phase",id:"validation-phase",level:3},{value:"Cutover Phase",id:"cutover-phase",level:3},{value:"Comparison Table",id:"comparison-table",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Rollback Plan",id:"rollback-plan",level:2},{value:"Post-Migration Optimization",id:"post-migration-optimization",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"migrating-from-karmada-to-kubestellar",children:"Migrating from Karmada to KubeStellar"})}),"\n",(0,l.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsx)(n.p,{children:"Karmada typically orchestrates multi-cluster deployments using:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"PropagationPolicy"})," / ",(0,l.jsx)(n.code,{children:"ClusterPropagationPolicy"})," for placement"]}),"\n",(0,l.jsx)(n.li,{children:"Scheduling rules for cluster selection"}),"\n",(0,l.jsx)(n.li,{children:"Overrides and replica scheduling for cluster-specific customization"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"KubeStellar provides:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Workload definitions in a ",(0,l.jsx)(n.strong,{children:"WDS"})]}),"\n",(0,l.jsxs)(n.li,{children:["Cluster selection via ",(0,l.jsx)(n.strong,{children:"BindingPolicy"})," ",(0,l.jsx)(n.code,{children:"clusterSelectors"})]}),"\n",(0,l.jsxs)(n.li,{children:["Transport and reconciliation via ",(0,l.jsx)(n.strong,{children:"ITS"})," and ",(0,l.jsx)(n.strong,{children:"OCM"})]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"This guide shows a practical mapping from Karmada policy constructs to KubeStellar BindingPolicies."}),"\n",(0,l.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Current Karmada control plane access"}),"\n",(0,l.jsx)(n.li,{children:"Inventory of propagated resources and target clusters"}),"\n",(0,l.jsx)(n.li,{children:"Plan for overlaps during transition (avoid double-management)"}),"\n",(0,l.jsx)(n.li,{children:"Working KubeStellar environment and WEC registration"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"migration-strategy",children:"Migration Strategy"}),"\n",(0,l.jsx)(n.h3,{id:"assessment-phase",children:"Assessment Phase"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["Inventory existing policies:","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Which resources are propagated?"}),"\n",(0,l.jsx)(n.li,{children:"Which cluster selectors are used?"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["Identify overrides:","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"per-cluster patches, replicas, image overrides"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"preparation-phase",children:"Preparation Phase"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["Register the same target clusters as ",(0,l.jsx)(n.strong,{children:"WECs"})," in KubeStellar ITS."]}),"\n",(0,l.jsx)(n.li,{children:"Apply equivalent labels in ITS to match Karmada selection intent."}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"kubectl config use-context its1\r\nkubectl label managedcluster cluster-a region=us-east env=prod --overwrite\r\nkubectl label managedcluster cluster-b region=eu-west env=prod --overwrite\n"})}),"\n",(0,l.jsxs)(n.ol,{start:"3",children:["\n",(0,l.jsxs)(n.li,{children:["Decide how to handle overrides:","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Prefer transforms or environment-specific manifests"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"migration-phase",children:"Migration Phase"}),"\n",(0,l.jsx)(n.h4,{id:"step-1-translate-placement-policy",children:"Step 1: Translate placement policy"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Before (Karmada PropagationPolicy)"})," (simplified):"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:"apiVersion: policy.karmada.io/v1alpha1\r\nkind: PropagationPolicy\r\nmetadata:\r\n  name: nginx-prop\r\nspec:\r\n  resourceSelectors:\r\n  - apiVersion: apps/v1\r\n    kind: Deployment\r\n    name: nginx\r\n  placement:\r\n    clusterAffinity:\r\n      clusterNames:\r\n      - cluster-a\r\n      - cluster-b\n"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"After (KubeStellar BindingPolicy)"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:"apiVersion: control.kubestellar.io/v1alpha1\r\nkind: BindingPolicy\r\nmetadata:\r\n  name: nginx-prod\r\n  namespace: demo\r\nspec:\r\n  clusterSelectors:\r\n  - matchLabels:\r\n      env: prod\r\n  downsync:\r\n  - objectSelectors:\r\n    - matchLabels:\r\n        app.kubernetes.io/name: nginx\r\n    resources:\r\n    - namespaces\r\n    - deployments\n"})}),"\n",(0,l.jsx)(n.h4,{id:"step-2-translate-resource-selection",children:"Step 2: Translate resource selection"}),"\n",(0,l.jsxs)(n.p,{children:["Karmada selects by GVK/name; KubeStellar commonly selects by ",(0,l.jsx)(n.strong,{children:"labels"}),"."]}),"\n",(0,l.jsx)(n.p,{children:"Best practice during migration:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Add stable labels to your workloads (e.g., ",(0,l.jsx)(n.code,{children:"app.kubernetes.io/name"}),", ",(0,l.jsx)(n.code,{children:"app.kubernetes.io/part-of"}),")"]}),"\n",(0,l.jsx)(n.li,{children:"Use those labels in BindingPolicy objectSelectors"}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"step-3-handle-overrides",children:"Step 3: Handle overrides"}),"\n",(0,l.jsx)(n.p,{children:"Karmada\u2019s per-cluster overrides can be expressed as:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Separate workload manifests per cluster group (recommended for clarity)"}),"\n",(0,l.jsx)(n.li,{children:"Transforms (where supported) for systematic patching"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"validation-phase",children:"Validation Phase"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"kubectl config use-context wds1\r\nkubectl get bindingpolicies -A\r\nkubectl get bindings -A\r\n\r\nkubectl get deploy -n demo --context cluster-a\r\nkubectl get deploy -n demo --context cluster-b\n"})}),"\n",(0,l.jsx)(n.h3,{id:"cutover-phase",children:"Cutover Phase"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Stop Karmada propagation for migrated workloads (remove policies or stop reconcilers)."}),"\n",(0,l.jsx)(n.li,{children:"Ensure only KubeStellar is driving desired state."}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"comparison-table",children:"Comparison Table"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Feature"}),(0,l.jsx)(n.th,{children:"Karmada"}),(0,l.jsx)(n.th,{children:"KubeStellar"}),(0,l.jsx)(n.th,{children:"Notes"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Placement object"}),(0,l.jsx)(n.td,{children:"PropagationPolicy"}),(0,l.jsx)(n.td,{children:"BindingPolicy"}),(0,l.jsx)(n.td,{children:"Both declarative"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Cluster selection"}),(0,l.jsx)(n.td,{children:"clusterAffinity / selectors"}),(0,l.jsx)(n.td,{children:"clusterSelectors (labels)"}),(0,l.jsx)(n.td,{children:"Label hygiene is key"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Overrides"}),(0,l.jsx)(n.td,{children:"OverridePolicy"}),(0,l.jsx)(n.td,{children:"Transforms / overlays"}),(0,l.jsx)(n.td,{children:"Choose the simplest reliable approach"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Transport"}),(0,l.jsx)(n.td,{children:"Karmada mechanisms"}),(0,l.jsx)(n.td,{children:"OCM via ITS"}),(0,l.jsx)(n.td,{children:"Different operational model"})]})]})]}),"\n",(0,l.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Workload selection via labels not added yet"}),"\n",(0,l.jsx)(n.li,{children:"Cluster labels missing in ITS"}),"\n",(0,l.jsx)(n.li,{children:"Two systems reconciling same resources simultaneously"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"rollback-plan",children:"Rollback Plan"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Keep Karmada policies available but disabled"}),"\n",(0,l.jsx)(n.li,{children:"If needed, remove BindingPolicy and re-enable Karmada propagation"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"post-migration-optimization",children:"Post-Migration Optimization"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Consolidate policies using labels instead of enumerating cluster names"}),"\n",(0,l.jsx)(n.li,{children:"Adopt ring-based release management"}),"\n",(0,l.jsx)(n.li,{children:"Standardize workload labeling"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},8453(e,n,r){r.d(n,{R:()=>a,x:()=>t});var i=r(6540);const l={},s=i.createContext(l);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);